<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="3.6.2">Jekyll</generator><link href="http://localhost:4000/feed.xml" rel="self" type="application/atom+xml" /><link href="http://localhost:4000/" rel="alternate" type="text/html" /><updated>2018-05-30T19:18:08-03:00</updated><id>http://localhost:4000/</id><title type="html">Leonardo Benedeti</title><subtitle>Meu site e base de conhecimento</subtitle><author><name>Leonardo Benedeti</name></author><entry><title type="html">Ionic app to list cards by heroky api</title><link href="http://localhost:4000/app-list-cards-by-heroku-api" rel="alternate" type="text/html" title="Ionic app to list cards by heroky api" /><published>2018-05-30T00:00:00-03:00</published><updated>2018-05-30T14:32:16-03:00</updated><id>http://localhost:4000/app-list-cards-by-heroku-api</id><content type="html" xml:base="http://localhost:4000/app-list-cards-by-heroku-api">&lt;p&gt;No mesmo happy hour do &lt;a href=&quot;./deploy-flask-api-on-heroku&quot;&gt;último post&lt;/a&gt;, além da API, houve a necessidade de um APP que pudesse entender essa API de maneira simples.&lt;/p&gt;

&lt;p&gt;Escopo: Rápido e básico, fazer um request em uma API que vai retornar uma lista e mostrar isso como cards.&lt;/p&gt;

&lt;p&gt;No papo também definimos que fazer isso com &lt;a href=&quot;http://ionicframework.com/&quot;&gt;Ionic&lt;/a&gt; seria bem tranquilo.&lt;/p&gt;

&lt;p&gt;Com tudo definido vamos a criação do app.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;ionic start listCardsByHerokuApi blank
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;~ A partir deste momento é preciso estar dentro da pasta do projeto, de preferência usando o Visual Studio Code.&lt;/p&gt;

&lt;p&gt;Vamos alterar o arquivo &lt;code class=&quot;highlighter-rouge&quot;&gt;[path-to-your-project]/src/app/app.module.ts&lt;/code&gt; para incluir um import.&lt;/p&gt;

&lt;div class=&quot;language-javascript highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;c1&quot;&gt;//incluir o import do HttpClientModule&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;import&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;HttpClientModule&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;from&lt;/span&gt; &lt;span class=&quot;s1&quot;&gt;'@angular/common/http'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; 
&lt;span class=&quot;p&quot;&gt;...&lt;/span&gt;
&lt;span class=&quot;nx&quot;&gt;imports&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;...&lt;/span&gt;
    &lt;span class=&quot;c1&quot;&gt;//incluir na lista de imports que o app precisa&lt;/span&gt;
    &lt;span class=&quot;nx&quot;&gt;HttpClientModule&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; 
    &lt;span class=&quot;p&quot;&gt;...&lt;/span&gt;
  &lt;span class=&quot;p&quot;&gt;],&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Próximo passo - Vamos precisar criar um provider com o seguinte comando&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;ionic g provider ListRest
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Após criar seu provider precisamos alterar algumas coisas nele.&lt;/p&gt;

&lt;p&gt;Vamos até ele então &lt;code class=&quot;highlighter-rouge&quot;&gt;[path-to-your-project]/src/providers/list-rest/list-rest.ts&lt;/code&gt;&lt;/p&gt;

&lt;div class=&quot;language-javascript highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  &lt;span class=&quot;c1&quot;&gt;// precisamos incluir o endpoint da api&lt;/span&gt;
  &lt;span class=&quot;nx&quot;&gt;endpoint&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;s1&quot;&gt;'https://api-flask-leonardobenedeti.herokuapp.com'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
  &lt;span class=&quot;p&quot;&gt;...&lt;/span&gt;
  &lt;span class=&quot;c1&quot;&gt;// e criar um metodo que retorna uma promise simples&lt;/span&gt;
  &lt;span class=&quot;c1&quot;&gt;// vamos tratar esta promise mais pra frente no home.ts&lt;/span&gt;
  &lt;span class=&quot;nx&quot;&gt;getList&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;api&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;Promise&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;((&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;resolve&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;reject&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&amp;gt;&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
      &lt;span class=&quot;k&quot;&gt;this&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;http&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;kd&quot;&gt;get&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;this&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;endpoint&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;+&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;api&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
      &lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;subscribe&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;data&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&amp;gt;&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;nx&quot;&gt;resolve&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;data&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
      &lt;span class=&quot;p&quot;&gt;},&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;err&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&amp;gt;&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;nx&quot;&gt;reject&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;err&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
      &lt;span class=&quot;p&quot;&gt;});&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;});&lt;/span&gt;
  &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Provider devidamente escrito, vamos alterar agora a tela que vai chamar essa lista.&lt;/p&gt;

&lt;p&gt;Como criamos um projeto baseado no template &lt;code class=&quot;highlighter-rouge&quot;&gt;blank&lt;/code&gt; do Ionic, temos apenas uma página, que é a &lt;code class=&quot;highlighter-rouge&quot;&gt;[path-to-your-project]/src/pages/home/&lt;/code&gt;.
Dentro da pasta dessa página temos 3 arquivos, mas vamos alterar apenas 2, &lt;code class=&quot;highlighter-rouge&quot;&gt;home.html&lt;/code&gt; e &lt;code class=&quot;highlighter-rouge&quot;&gt;home.ts&lt;/code&gt;, o &lt;code class=&quot;highlighter-rouge&quot;&gt;home.scss&lt;/code&gt; fica pra um próximo post.&lt;/p&gt;

&lt;p&gt;Vamos ao &lt;code class=&quot;highlighter-rouge&quot;&gt;.ts&lt;/code&gt;, que é quem vai buscar a lista utilizando o provider que criamos acima.&lt;/p&gt;

&lt;div class=&quot;language-javascript highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;import&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;Component&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;from&lt;/span&gt; &lt;span class=&quot;s1&quot;&gt;'@angular/core'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;import&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;NavController&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;LoadingController&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;from&lt;/span&gt; &lt;span class=&quot;s1&quot;&gt;'ionic-angular'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;import&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;ListRestProvider&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;from&lt;/span&gt; &lt;span class=&quot;s1&quot;&gt;'../../providers/list-rest/list-rest'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;

&lt;span class=&quot;p&quot;&gt;@&lt;/span&gt;&lt;span class=&quot;nd&quot;&gt;Component&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;({&lt;/span&gt;
  &lt;span class=&quot;na&quot;&gt;selector&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s1&quot;&gt;'page-home'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
  &lt;span class=&quot;na&quot;&gt;templateUrl&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s1&quot;&gt;'home.html'&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;})&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;export&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;HomePage&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;

  &lt;span class=&quot;c1&quot;&gt;// incluir o list rest para podermos buscar a lista&lt;/span&gt;
  &lt;span class=&quot;c1&quot;&gt;// incluir o loadingControler para não deixar o usuário esperando sem informar&lt;/span&gt;
  &lt;span class=&quot;c1&quot;&gt;// Ambos precisam do import, se estiver utilizando o VSCode provavelmente ele já importou pra você.&lt;/span&gt;
  &lt;span class=&quot;c1&quot;&gt;// Caso contrário, copie os imports acima.&lt;/span&gt;
  &lt;span class=&quot;kd&quot;&gt;constructor&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;
    &lt;span class=&quot;kr&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;navCtrl&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;NavController&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
    &lt;span class=&quot;kr&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;listRest&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;ListRestProvider&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; 
    &lt;span class=&quot;kr&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;loadingCtrl&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;LoadingController&lt;/span&gt; 
  &lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{}&lt;/span&gt;

  &lt;span class=&quot;c1&quot;&gt;// definição de uma variável tipo any para abrigar os cards&lt;/span&gt;
  &lt;span class=&quot;nl&quot;&gt;cards&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;any&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;

  &lt;span class=&quot;nx&quot;&gt;ionViewDidLoad&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;this&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;getCards&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt; 
  &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

  &lt;span class=&quot;nx&quot;&gt;getCards&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(){&lt;/span&gt;
    &lt;span class=&quot;c1&quot;&gt;// quando iniciarmos a request já vamos ter um loading na tela, informando o usuário que algo está acontecendo&lt;/span&gt;
    &lt;span class=&quot;kd&quot;&gt;let&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;loading&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;this&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;loadingCtrl&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;create&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;({&lt;/span&gt;
      &lt;span class=&quot;na&quot;&gt;content&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s1&quot;&gt;''&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;});&lt;/span&gt;
    &lt;span class=&quot;nx&quot;&gt;loading&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;present&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;

    &lt;span class=&quot;c1&quot;&gt;// chamada para o provider que criamos anteriormente passando a api que vamos utilizar, / no caso.&lt;/span&gt;
    &lt;span class=&quot;c1&quot;&gt;// com o retorno da promise, basta tratar o then ou catch&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;this&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;listRest&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;getList&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s1&quot;&gt;'/'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;then&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;data&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&amp;gt;&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
      &lt;span class=&quot;k&quot;&gt;this&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;cards&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;data&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;s1&quot;&gt;'cards'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;];&lt;/span&gt;
      &lt;span class=&quot;nx&quot;&gt;loading&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;dismiss&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;})&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;catch&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;err&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&amp;gt;&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
      &lt;span class=&quot;nx&quot;&gt;loading&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;dismiss&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;
      &lt;span class=&quot;c1&quot;&gt;// evite usar alerts comuns como utilizei, ele bloqueia o resto da execução, pode deixar seu app atrapalhado&lt;/span&gt;
      &lt;span class=&quot;c1&quot;&gt;// Dica para este caso é utilizar o AlertController do próprio Ionic&lt;/span&gt;
      &lt;span class=&quot;nx&quot;&gt;alert&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;Algo de errado não está certo. Tente novamente!&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;});&lt;/span&gt;
  &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Agora para mostrar o que foi feito no &lt;code class=&quot;highlighter-rouge&quot;&gt;.ts&lt;/code&gt; vamos alterar o &lt;code class=&quot;highlighter-rouge&quot;&gt;.html&lt;/code&gt;.&lt;/p&gt;

&lt;div class=&quot;language-html highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nt&quot;&gt;&amp;lt;ion-header&amp;gt;&lt;/span&gt;
  &lt;span class=&quot;nt&quot;&gt;&amp;lt;ion-navbar&amp;gt;&lt;/span&gt;
    &lt;span class=&quot;nt&quot;&gt;&amp;lt;ion-title&amp;gt;&lt;/span&gt;
      Ionic Blank
    &lt;span class=&quot;nt&quot;&gt;&amp;lt;/ion-title&amp;gt;&lt;/span&gt;
  &lt;span class=&quot;nt&quot;&gt;&amp;lt;/ion-navbar&amp;gt;&lt;/span&gt;
&lt;span class=&quot;nt&quot;&gt;&amp;lt;/ion-header&amp;gt;&lt;/span&gt;

&lt;span class=&quot;nt&quot;&gt;&amp;lt;ion-content&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;padding&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&amp;gt;&lt;/span&gt;
  &lt;span class=&quot;c&quot;&gt;&amp;lt;!-- usando o template basico, removemos tudo dentro de ion-content e incluimos o card abaixo --&amp;gt;&lt;/span&gt;
  &lt;span class=&quot;c&quot;&gt;&amp;lt;!-- repare o *ngFor que estamos fazendo, a variável cards é a mesma do home.ts que alimentamos com a lista que o provider devolveu, elas devem ter o mesmo nome  --&amp;gt;&lt;/span&gt;
  &lt;span class=&quot;nt&quot;&gt;&amp;lt;ion-card&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;ngFor=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;let card of cards&quot;&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&amp;gt;&lt;/span&gt; 
    &lt;span class=&quot;c&quot;&gt;&amp;lt;!-- agora para cada item da lista ele vai escrever um card --&amp;gt;&lt;/span&gt;
    &lt;span class=&quot;nt&quot;&gt;&amp;lt;ion-card-header&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;innerHTML&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;]=&quot;&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;card&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;title&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&amp;gt;&amp;lt;/ion-card-header&amp;gt;&lt;/span&gt;
    &lt;span class=&quot;nt&quot;&gt;&amp;lt;ion-card-content&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;innerHTML&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;]=&quot;&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;card&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;desc&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&amp;gt;&amp;lt;/ion-card-content&amp;gt;&lt;/span&gt;
  &lt;span class=&quot;nt&quot;&gt;&amp;lt;/ion-card&amp;gt;&lt;/span&gt;
&lt;span class=&quot;nt&quot;&gt;&amp;lt;/ion-content&amp;gt;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;~ Ignorem os erros do arquivo, é algo do jekyll, em breve ajeito isso. =D&lt;/p&gt;

&lt;p&gt;Neste ponto estamos prontos para executar nosso app, como estamos fazendo uma requisição com loading e tudo mais, vamos testar em um device para ver como se comporta.
Para isso precisamos incluir a plataforma necessária para o teste.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;ionic cordova platform add android
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Utilizei a plataforma Android por ser mais simples e não precisar configurar certificados e tudo que a Apple demanda.&lt;/p&gt;

&lt;p&gt;Após adicionar a plataforma, basta executar este comando com o device conectado ao computador. Ao finalizar o build, ele vai instalar no device o app que foi criado.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;ionic cordova run android --device
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;E pronto. Aqui temos um aplicativo que é capaz de buscar uma lista de uma API e transformar em Cards.&lt;/p&gt;

&lt;div style=&quot;display:flex;&quot;&gt;
    &lt;img src=&quot;assets/img/list-cards-by-heroku/loading.png&quot; style=&quot;margin:20px auto;border: 1px solid #000;padding: 5px;&quot; alt=&quot;&quot; /&gt;
    &lt;img src=&quot;assets/img/list-cards-by-heroku/cards.png&quot; style=&quot;margin:20px auto;border: 1px solid #000;padding: 5px;&quot; alt=&quot;&quot; /&gt;
&lt;/div&gt;

&lt;hr /&gt;

&lt;p&gt;Pra visualizar a API citada neste post basta ir para: &lt;a href=&quot;https://api-flask-leonardobenedeti.herokuapp.com/&quot;&gt;https://api-flask-leonardobenedeti.herokuapp.com/&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;Para baixar os códigos mostrados acima basta acessar:
&lt;a href=&quot;https://github.com/leonardobenedeti/ionic-app-list-cards-by-heroku-api&quot;&gt;https://github.com/leonardobenedeti/ionic-app-list-cards-by-heroku-api&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;Para baixar o apk criado neste exemplo basta &lt;a href=&quot;./assets/files/app-list-cards-by-heroku-api.apk&quot;&gt;clicar aqui&lt;/a&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;Fonte: &lt;a href=&quot;https://www.djamware.com/post/59924f9080aca768e4d2b12e/ionic-3-consuming-rest-api-using-new-angular-43-httpclient&quot;&gt;https://www.djamwa…43-httpclient&lt;/a&gt;&lt;/p&gt;</content><author><name>Leonardo Benedeti</name></author><category term="ionic" /><category term="rest" /><category term="api" /><category term="heroku" /><summary type="html">No mesmo happy hour do último post, além da API, houve a necessidade de um APP que pudesse entender essa API de maneira simples. Escopo: Rápido e básico, fazer um request em uma API que vai retornar uma lista e mostrar isso como cards. No papo também definimos que fazer isso com Ionic seria bem tranquilo. Com tudo definido vamos a criação do app. ionic start listCardsByHerokuApi blank ~ A partir deste momento é preciso estar dentro da pasta do projeto, de preferência usando o Visual Studio Code. Vamos alterar o arquivo [path-to-your-project]/src/app/app.module.ts para incluir um import. //incluir o import do HttpClientModule import { HttpClientModule } from '@angular/common/http'; ... imports: [ ... //incluir na lista de imports que o app precisa HttpClientModule, ... ], Próximo passo - Vamos precisar criar um provider com o seguinte comando ionic g provider ListRest Após criar seu provider precisamos alterar algumas coisas nele. Vamos até ele então [path-to-your-project]/src/providers/list-rest/list-rest.ts // precisamos incluir o endpoint da api endpoint = 'https://api-flask-leonardobenedeti.herokuapp.com'; ... // e criar um metodo que retorna uma promise simples // vamos tratar esta promise mais pra frente no home.ts getList(api) { return new Promise((resolve, reject) =&amp;gt; { this.http.get(this.endpoint+api) .subscribe(data =&amp;gt; { resolve(data); }, err =&amp;gt; { reject(err) }); }); } Provider devidamente escrito, vamos alterar agora a tela que vai chamar essa lista. Como criamos um projeto baseado no template blank do Ionic, temos apenas uma página, que é a [path-to-your-project]/src/pages/home/. Dentro da pasta dessa página temos 3 arquivos, mas vamos alterar apenas 2, home.html e home.ts, o home.scss fica pra um próximo post. Vamos ao .ts, que é quem vai buscar a lista utilizando o provider que criamos acima. import { Component } from '@angular/core'; import { NavController, LoadingController } from 'ionic-angular'; import { ListRestProvider } from '../../providers/list-rest/list-rest'; @Component({ selector: 'page-home', templateUrl: 'home.html' }) export class HomePage { // incluir o list rest para podermos buscar a lista // incluir o loadingControler para não deixar o usuário esperando sem informar // Ambos precisam do import, se estiver utilizando o VSCode provavelmente ele já importou pra você. // Caso contrário, copie os imports acima. constructor( public navCtrl: NavController, public listRest: ListRestProvider, public loadingCtrl: LoadingController ) {} // definição de uma variável tipo any para abrigar os cards cards: any; ionViewDidLoad() { this.getCards(); } getCards(){ // quando iniciarmos a request já vamos ter um loading na tela, informando o usuário que algo está acontecendo let loading = this.loadingCtrl.create({ content: '' }); loading.present(); // chamada para o provider que criamos anteriormente passando a api que vamos utilizar, / no caso. // com o retorno da promise, basta tratar o then ou catch this.listRest.getList('/') .then(data =&amp;gt; { this.cards = data['cards']; loading.dismiss(); }) .catch(err =&amp;gt; { loading.dismiss(); // evite usar alerts comuns como utilizei, ele bloqueia o resto da execução, pode deixar seu app atrapalhado // Dica para este caso é utilizar o AlertController do próprio Ionic alert(&quot;Algo de errado não está certo. Tente novamente!&quot;) }); } } Agora para mostrar o que foi feito no .ts vamos alterar o .html. &amp;lt;ion-header&amp;gt; &amp;lt;ion-navbar&amp;gt; &amp;lt;ion-title&amp;gt; Ionic Blank &amp;lt;/ion-title&amp;gt; &amp;lt;/ion-navbar&amp;gt; &amp;lt;/ion-header&amp;gt; &amp;lt;ion-content padding&amp;gt; &amp;lt;!-- usando o template basico, removemos tudo dentro de ion-content e incluimos o card abaixo --&amp;gt; &amp;lt;!-- repare o *ngFor que estamos fazendo, a variável cards é a mesma do home.ts que alimentamos com a lista que o provider devolveu, elas devem ter o mesmo nome --&amp;gt; &amp;lt;ion-card *ngFor=&quot;let card of cards&quot;&amp;gt; &amp;lt;!-- agora para cada item da lista ele vai escrever um card --&amp;gt; &amp;lt;ion-card-header [innerHTML]=&quot;card.title&quot;&amp;gt;&amp;lt;/ion-card-header&amp;gt; &amp;lt;ion-card-content [innerHTML]=&quot;card.desc&quot;&amp;gt;&amp;lt;/ion-card-content&amp;gt; &amp;lt;/ion-card&amp;gt; &amp;lt;/ion-content&amp;gt; ~ Ignorem os erros do arquivo, é algo do jekyll, em breve ajeito isso. =D Neste ponto estamos prontos para executar nosso app, como estamos fazendo uma requisição com loading e tudo mais, vamos testar em um device para ver como se comporta. Para isso precisamos incluir a plataforma necessária para o teste. ionic cordova platform add android Utilizei a plataforma Android por ser mais simples e não precisar configurar certificados e tudo que a Apple demanda. Após adicionar a plataforma, basta executar este comando com o device conectado ao computador. Ao finalizar o build, ele vai instalar no device o app que foi criado. ionic cordova run android --device E pronto. Aqui temos um aplicativo que é capaz de buscar uma lista de uma API e transformar em Cards. Pra visualizar a API citada neste post basta ir para: https://api-flask-leonardobenedeti.herokuapp.com/ Para baixar os códigos mostrados acima basta acessar: https://github.com/leonardobenedeti/ionic-app-list-cards-by-heroku-api Para baixar o apk criado neste exemplo basta clicar aqui Fonte: https://www.djamwa…43-httpclient</summary></entry><entry><title type="html">Deploy flask API on Heroku</title><link href="http://localhost:4000/deploy-flask-api-on-heroku" rel="alternate" type="text/html" title="Deploy flask API on Heroku" /><published>2018-05-25T00:00:00-03:00</published><updated>2018-05-25T14:32:16-03:00</updated><id>http://localhost:4000/deploy-flask-api-on-heroku</id><content type="html" xml:base="http://localhost:4000/deploy-flask-api-on-heroku">&lt;p&gt;Em um happy hour com o pessoal do trabalho, rolou um papo de api em python e a curiosidade para criar isso se iniciou. 
Não sou tão bom assim com python, mas decidi iniciar os estudos sobre o papo direto com a lib Flask, focada em apis.&lt;/p&gt;

&lt;p&gt;Após alguns minutos de busca e vídeos assistidos, tinha uma api rodando localmente na minha máquina. Com pouco mais de 10 linhas e alguns imports uma api já estava pronta, é claro, apenas com uma resposta de ‘hello world’, mas ainda sim já estava funcional.&lt;/p&gt;

&lt;p&gt;Outra necessidade era expor essa api em algum lugar, foi ai que pensamos no &lt;a href=&quot;https://www.heroku.com/&quot;&gt;Heroku&lt;/a&gt;, gratuito e fácil de usar. Abaixo, vou mostrar como fazer o deploy de uma api, que você pode baixar e ver como foi feita meu &lt;a href=&quot;https://github.com/leonardobenedeti/api-flask&quot;&gt;GitHub&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;Levando em consideração que os arquivos já estejam prontos e rodando localmente, temos duas opções após criar o app no Heroku:
1 - vincular com algum repositório do github e criar um pipeline, onde você commita na branch escolhida no github e o Heroku faz o deploy a partir dela.
2 - vincular com o própio heroku, que é baseado em git também.&lt;/p&gt;

&lt;p&gt;Mas antes de criar a api precisamos criar o app no Heroku.
Pra isso vamos seguir alguns passos.&lt;/p&gt;

&lt;h4 id=&quot;00---criar-app-sem-definição-de-plataforma&quot;&gt;0.0 - Criar app sem definição de plataforma&lt;/h4&gt;
&lt;p&gt;&lt;img src=&quot;assets/img/heroku-deploy/create-app.png&quot; style=&quot;margin:20px auto;&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;h4 id=&quot;01---escolher-nome-e-região&quot;&gt;0.1 - Escolher nome e região&lt;/h4&gt;
&lt;p&gt;&lt;img src=&quot;assets/img/heroku-deploy/nome-e-regiao.png&quot; style=&quot;margin:20px auto;&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Com estes dois itens já criados, vamos vincular com o GitHub e Heroku.&lt;/p&gt;

&lt;h4 id=&quot;10---vincular-com-o-github&quot;&gt;1.0 - Vincular com o github&lt;/h4&gt;

&lt;p&gt;No print eu já estava vinculado com o github, mas basta clicar em conctar e colocar usuário e senha do github pra buscar seus repositorios e escolher o que abriga a sua api, no meu caso, api-flask.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;assets/img/heroku-deploy/vinculo-com-github.png&quot; style=&quot;margin:20px auto;&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;h4 id=&quot;11---configurar-os-deploys&quot;&gt;1.1 - Configurar os deploys&lt;/h4&gt;

&lt;p&gt;No meu caso como é uma api aberta e de exemplo, escolhi o deploy automático. Pois a cada commit que eu faça na api, em questão de segundos já posso visualizar o que foi alterado.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;assets/img/heroku-deploy/deploy-auto-manual.png&quot; style=&quot;margin:20px auto;&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;E pronto. A partir daqui basta commitar na branch escolhida no momento do vínculo com o GitHub e pronto, seu deploy vai ser feito automaticamente, caso tenha habilitado a opção.&lt;/p&gt;

&lt;h4 id=&quot;20---vincular-com-o-próprio-heroku&quot;&gt;2.0 - Vincular com o próprio heroku&lt;/h4&gt;

&lt;p&gt;Neste caso precisei criar outro app para printar, não ia apagar e criar outro rsrs.&lt;/p&gt;

&lt;p&gt;Para este vínculo, você não é preciso ter login no github, precisa apenas seguir os commandos que ele recomenda. Simples assim.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;assets/img/heroku-deploy/vinculo-com-heroku.png&quot; style=&quot;margin:20px auto;&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Agora, basta você customizar sua api como quiser, commitar onde escolheu subir o código e aproveitar a facilidade do Flask + Heroku.&lt;/p&gt;

&lt;p&gt;Pra visualizar o exemplo criado no repositório citado acima basta ir para: &lt;a href=&quot;https://api-flask-leonardobenedeti.herokuapp.com/&quot;&gt;https://api-flask-leonardobenedeti.herokuapp.com/&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;Fonte: &lt;a href=&quot;https://progblog.io/How-to-deploy-a-Flask-App-to-Heroku/&quot;&gt;https://progblog…k-App-to-Heroku/&lt;/a&gt;&lt;/p&gt;</content><author><name>Leonardo Benedeti</name></author><category term="python" /><category term="flash" /><category term="heroku" /><summary type="html">Em um happy hour com o pessoal do trabalho, rolou um papo de api em python e a curiosidade para criar isso se iniciou. Não sou tão bom assim com python, mas decidi iniciar os estudos sobre o papo direto com a lib Flask, focada em apis. Após alguns minutos de busca e vídeos assistidos, tinha uma api rodando localmente na minha máquina. Com pouco mais de 10 linhas e alguns imports uma api já estava pronta, é claro, apenas com uma resposta de ‘hello world’, mas ainda sim já estava funcional. Outra necessidade era expor essa api em algum lugar, foi ai que pensamos no Heroku, gratuito e fácil de usar. Abaixo, vou mostrar como fazer o deploy de uma api, que você pode baixar e ver como foi feita meu GitHub. Levando em consideração que os arquivos já estejam prontos e rodando localmente, temos duas opções após criar o app no Heroku: 1 - vincular com algum repositório do github e criar um pipeline, onde você commita na branch escolhida no github e o Heroku faz o deploy a partir dela. 2 - vincular com o própio heroku, que é baseado em git também. Mas antes de criar a api precisamos criar o app no Heroku. Pra isso vamos seguir alguns passos. 0.0 - Criar app sem definição de plataforma 0.1 - Escolher nome e região Com estes dois itens já criados, vamos vincular com o GitHub e Heroku. 1.0 - Vincular com o github No print eu já estava vinculado com o github, mas basta clicar em conctar e colocar usuário e senha do github pra buscar seus repositorios e escolher o que abriga a sua api, no meu caso, api-flask. 1.1 - Configurar os deploys No meu caso como é uma api aberta e de exemplo, escolhi o deploy automático. Pois a cada commit que eu faça na api, em questão de segundos já posso visualizar o que foi alterado. E pronto. A partir daqui basta commitar na branch escolhida no momento do vínculo com o GitHub e pronto, seu deploy vai ser feito automaticamente, caso tenha habilitado a opção. 2.0 - Vincular com o próprio heroku Neste caso precisei criar outro app para printar, não ia apagar e criar outro rsrs. Para este vínculo, você não é preciso ter login no github, precisa apenas seguir os commandos que ele recomenda. Simples assim. Agora, basta você customizar sua api como quiser, commitar onde escolheu subir o código e aproveitar a facilidade do Flask + Heroku. Pra visualizar o exemplo criado no repositório citado acima basta ir para: https://api-flask-leonardobenedeti.herokuapp.com/ Fonte: https://progblog…k-App-to-Heroku/</summary></entry><entry><title type="html">Override keys configs do info.plist para Ionic 3</title><link href="http://localhost:4000/ionic-override-keys-info-plist" rel="alternate" type="text/html" title="Override keys configs do info.plist para Ionic 3" /><published>2018-05-16T00:00:00-03:00</published><updated>2018-05-16T14:32:16-03:00</updated><id>http://localhost:4000/ionic-override-keys-info-plist</id><content type="html" xml:base="http://localhost:4000/ionic-override-keys-info-plist">&lt;p&gt;Ao atualizar um projeto ionic, do 1 para o 3, precisei rever alguns guides da Apple referente a permissões de uso de recursos nativos.
Neste caso precisei utilizar a câmera e a configuração básica deste plugin não estava criando a chave de descrição para o info.plist, com isso ao executar a chamada para a câmera o aplicativo crashava. 
Ao procurar o motivo encontrei a key &lt;code class=&quot;highlighter-rouge&quot;&gt;NSCameraUsageDescription&lt;/code&gt; sem valor algum. Ao incluir um valor de teste, tudo voltou a funcionar. 
Porém o projeto XCode é sempre refeito quando se faz um novo build, alterar a cada build não seria algo prático e busquei a solução abaixo.&lt;/p&gt;

&lt;p&gt;No arquivo config.xml é onde ficam todas as configurações básicas do ionic para gerar o projeto de cada plataforma.&lt;/p&gt;

&lt;p&gt;Como é algo focado em iOS, precisamos definir essas tags dentro da tag ‘Mãe’ &lt;code class=&quot;highlighter-rouge&quot;&gt;&amp;lt;platform name=&quot;ios&quot;&amp;gt;&lt;/code&gt;, onde obviamente são definidas as propriedades do build para o XCode.&lt;/p&gt;

&lt;p&gt;config.xml:&lt;/p&gt;
&lt;div class=&quot;language-xml highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nt&quot;&gt;&amp;lt;platform&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;name=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;ios&quot;&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&amp;gt;&lt;/span&gt;
...
    &lt;span class=&quot;nt&quot;&gt;&amp;lt;config-file&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;parent=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;NSCameraUsageDescription&quot;&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;platform=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;ios&quot;&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;target=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;*-Info.plist&quot;&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&amp;gt;&lt;/span&gt;
        &lt;span class=&quot;nt&quot;&gt;&amp;lt;string&amp;gt;&lt;/span&gt;Texto explicando o porque você quer usar a câmera&lt;span class=&quot;nt&quot;&gt;&amp;lt;/string&amp;gt;&lt;/span&gt;
    &lt;span class=&quot;nt&quot;&gt;&amp;lt;/config-file&amp;gt;&lt;/span&gt;
...    
&lt;span class=&quot;nt&quot;&gt;&amp;lt;/platform&amp;gt;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Com isso ele altera a key e inclui o valor que você escreveu na tag &lt;code class=&quot;highlighter-rouge&quot;&gt;&amp;lt;string&amp;gt;&lt;/code&gt;, com isso você consegue utilizar a câmera com a devida permissão.&lt;/p&gt;

&lt;p&gt;Vale ressaltar que basta trocar a key e o valor para ser alterada no info.plist, ou seja, quer trocar a de localização por exemplo ?
Basta descobrir o nome da key, que sendo de localização é &lt;code class=&quot;highlighter-rouge&quot;&gt;NSLocationWhenInUseUsageDescription&lt;/code&gt; e criar a mesma tag pra ele, incluir um texto explicando o porque e pronto. Ao fazer o build do aplicativo você vai conseguir utilizar o recurso desejado.&lt;/p&gt;

&lt;p&gt;Fonte: &lt;a href=&quot;https://stackoverflow.com/questions/39980700/usage-description-issue-in-ionic-and-ios-10-builds/40466511&quot;&gt;https://stackove…-10-builds/40466511&lt;/a&gt;&lt;/p&gt;</content><author><name>Leonardo Benedeti</name></author><category term="ionic" /><category term="ios" /><category term="info-plist" /><summary type="html">Ao atualizar um projeto ionic, do 1 para o 3, precisei rever alguns guides da Apple referente a permissões de uso de recursos nativos. Neste caso precisei utilizar a câmera e a configuração básica deste plugin não estava criando a chave de descrição para o info.plist, com isso ao executar a chamada para a câmera o aplicativo crashava. Ao procurar o motivo encontrei a key NSCameraUsageDescription sem valor algum. Ao incluir um valor de teste, tudo voltou a funcionar. Porém o projeto XCode é sempre refeito quando se faz um novo build, alterar a cada build não seria algo prático e busquei a solução abaixo. No arquivo config.xml é onde ficam todas as configurações básicas do ionic para gerar o projeto de cada plataforma. Como é algo focado em iOS, precisamos definir essas tags dentro da tag ‘Mãe’ &amp;lt;platform name=&quot;ios&quot;&amp;gt;, onde obviamente são definidas as propriedades do build para o XCode. config.xml: &amp;lt;platform name=&quot;ios&quot;&amp;gt; ... &amp;lt;config-file parent=&quot;NSCameraUsageDescription&quot; platform=&quot;ios&quot; target=&quot;*-Info.plist&quot;&amp;gt; &amp;lt;string&amp;gt;Texto explicando o porque você quer usar a câmera&amp;lt;/string&amp;gt; &amp;lt;/config-file&amp;gt; ... &amp;lt;/platform&amp;gt; Com isso ele altera a key e inclui o valor que você escreveu na tag &amp;lt;string&amp;gt;, com isso você consegue utilizar a câmera com a devida permissão. Vale ressaltar que basta trocar a key e o valor para ser alterada no info.plist, ou seja, quer trocar a de localização por exemplo ? Basta descobrir o nome da key, que sendo de localização é NSLocationWhenInUseUsageDescription e criar a mesma tag pra ele, incluir um texto explicando o porque e pronto. Ao fazer o build do aplicativo você vai conseguir utilizar o recurso desejado. Fonte: https://stackove…-10-builds/40466511</summary></entry><entry><title type="html">Página de eventos para a comunidade RioSulValley</title><link href="http://localhost:4000/events-page-from-riosulvalley" rel="alternate" type="text/html" title="Página de eventos para a comunidade RioSulValley" /><published>2018-04-17T00:00:00-03:00</published><updated>2018-04-17T14:32:16-03:00</updated><id>http://localhost:4000/events-page-from-riosulvalley</id><content type="html" xml:base="http://localhost:4000/events-page-from-riosulvalley">&lt;p&gt;&lt;img src=&quot;assets/img/rsv-eventos.png&quot; style=&quot;margin:40px auto;&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Depois de um longo papo sobre fazer ou não uma pagina de eventos e como fazer isso pela comunidade &lt;a href=&quot;http://riosulvalley.com.br&quot;&gt;RioSulValley&lt;/a&gt;, me propus a ajudar a criar essa tal página. 
Criamos um grupo onde apenas os interessados em ajudar estavam presentes, eram estes: &lt;a href=&quot;&quot;&gt;Kaio Freitas&lt;/a&gt; - o cara que normalmente toma a frente da comunidade em diversos assuntos; &lt;a href=&quot;&quot;&gt;Ivo Soares&lt;/a&gt; - desenvolvedor atuante na comunidade, e quem mostrou a ideia que usamos para criar a página; Eu - desenvolvedor atuante na comunidade sempre que posso rsrs.&lt;/p&gt;

&lt;p&gt;Com o grupo formado iniciamos o bate papo para criar essa tal página. Com uma ideia, Ivo mostrou uma página que fazia o mesmo que queriamos fazer para o RSV, era a &lt;a href=&quot;http://frontendbr.com.br/eventos/&quot;&gt;página eventos&lt;/a&gt; da comunidade &lt;a href=&quot;http://frontendbr.com.br&quot;&gt;Front-End Brasil&lt;/a&gt;, como é uma comunidade também, o código estava aberto no &lt;a href=&quot;https://github.com/frontendbr/eventos&quot;&gt;github&lt;/a&gt; deles. Sendo assim, carinhosamente fizemos um fork do projeto e iniciamos as alterações.&lt;/p&gt;

&lt;p&gt;No início atuei alterando o front para as cores e conteúdos do RSV, ao finalizar essa parte que em teoria seria a mais simples rsrs, fomos para a parte funcional da página. O Front-End Brasil, pelo próprio nome já se explica é uma comunidade em nível nacional e o RSV é regional, abrangendo todo Sul Fluminense do Rio de Janeiro, com isso precisamos alterar um dos filtros que listava os eventos por ESTADOS. Alteramos este filtro para CIDADES e assim todas as alterações que tinhamos em mente estavam prontas.&lt;/p&gt;

&lt;p&gt;Com o front alterado, o Ivo iniciou sua atuação, preparando tudo que foi desenvolvido para fazendo o build final da aplicação para publicar no github pages do RSV gerando o link &lt;a href=&quot;http://riosulvalley.com.br/eventos&quot;&gt;riosulvalley.com.br/eventos&lt;/a&gt;.&lt;/p&gt;</content><author><name>Leonardo Benedeti</name></author><category term="react" /><category term="webpack" /><category term="npm" /><summary type="html">Depois de um longo papo sobre fazer ou não uma pagina de eventos e como fazer isso pela comunidade RioSulValley, me propus a ajudar a criar essa tal página. Criamos um grupo onde apenas os interessados em ajudar estavam presentes, eram estes: Kaio Freitas - o cara que normalmente toma a frente da comunidade em diversos assuntos; Ivo Soares - desenvolvedor atuante na comunidade, e quem mostrou a ideia que usamos para criar a página; Eu - desenvolvedor atuante na comunidade sempre que posso rsrs. Com o grupo formado iniciamos o bate papo para criar essa tal página. Com uma ideia, Ivo mostrou uma página que fazia o mesmo que queriamos fazer para o RSV, era a página eventos da comunidade Front-End Brasil, como é uma comunidade também, o código estava aberto no github deles. Sendo assim, carinhosamente fizemos um fork do projeto e iniciamos as alterações. No início atuei alterando o front para as cores e conteúdos do RSV, ao finalizar essa parte que em teoria seria a mais simples rsrs, fomos para a parte funcional da página. O Front-End Brasil, pelo próprio nome já se explica é uma comunidade em nível nacional e o RSV é regional, abrangendo todo Sul Fluminense do Rio de Janeiro, com isso precisamos alterar um dos filtros que listava os eventos por ESTADOS. Alteramos este filtro para CIDADES e assim todas as alterações que tinhamos em mente estavam prontas. Com o front alterado, o Ivo iniciou sua atuação, preparando tudo que foi desenvolvido para fazendo o build final da aplicação para publicar no github pages do RSV gerando o link riosulvalley.com.br/eventos.</summary></entry><entry><title type="html">White page after splash screen on ionic before ready</title><link href="http://localhost:4000/white-page-after-slash-screen-ionic-before-ready" rel="alternate" type="text/html" title="White page after splash screen on ionic before ready" /><published>2018-01-26T00:00:00-02:00</published><updated>2018-01-26T15:32:16-02:00</updated><id>http://localhost:4000/white-page-after-slash-screen-ionic-before-ready</id><content type="html" xml:base="http://localhost:4000/white-page-after-slash-screen-ionic-before-ready">&lt;p&gt;Ao iniciar um projeto ionic, eu reparei que a splash tinha um comportamento estranho. 
Ao finalizar o fade de saída, a tela do app ainda não tinha carregado, mostrando assim uma tela branca antes do conteúdo. 
Fui investigar o porque e descobri algumas &lt;code class=&quot;highlighter-rouge&quot;&gt;preferences&lt;/code&gt; que corrigem esse comportamento.
Normalmente as splash screens servem para preparar o app, e ao finalizar o carregamento dos arquivos ela faz o fade dando foco ao conteúdo da tela inicial do seu aplicativo.&lt;/p&gt;

&lt;p&gt;Neste post vamos alterar apenas dois arquivos pra que isso de fato aconteça. O config.xml e o app.js&lt;/p&gt;

&lt;p&gt;Para previnir que a splash execute o fade automaticamente antes do conteúdo estar pronto, você precisa da preference: &lt;code class=&quot;highlighter-rouge&quot;&gt;AutoHideSplashScreen&lt;/code&gt;, que é quem previne isso, se estiver com valor &lt;code class=&quot;highlighter-rouge&quot;&gt;false&lt;/code&gt;.
As demais preferences são para melhorar a experiência da splash, os nomes já se auto explicam né. =D&lt;/p&gt;

&lt;p&gt;config.xml:&lt;/p&gt;
&lt;div class=&quot;language-xml highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;    &lt;span class=&quot;nt&quot;&gt;&amp;lt;preference&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;name=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;AutoHideSplashScreen&quot;&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;value=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;false&quot;&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;/&amp;gt;&lt;/span&gt;
    &lt;span class=&quot;nt&quot;&gt;&amp;lt;preference&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;name=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;FadeSplashScreenDuration&quot;&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;value=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;1000&quot;&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;/&amp;gt;&lt;/span&gt;
    &lt;span class=&quot;nt&quot;&gt;&amp;lt;preference&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;name=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;ShowSplashScreenSpinner&quot;&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;value=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;false&quot;&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;/&amp;gt;&lt;/span&gt;
    &lt;span class=&quot;nt&quot;&gt;&amp;lt;preference&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;name=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;SplashMaintainAspectRatio&quot;&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;value=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;true&quot;&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;/&amp;gt;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Com os valores do config.xml definidos basta incluir este trecho de código no arquivo app.js para a magia acontecer.&lt;/p&gt;

&lt;p&gt;Atenção: para ele funcionar como combinado, ele precisa estar dentro do ready, para que assim que de fato ele esteja pronto e a splash pode ser esmaecida. =D&lt;/p&gt;

&lt;p&gt;app.js:&lt;/p&gt;
&lt;div class=&quot;language-js highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;    &lt;span class=&quot;nx&quot;&gt;setTimeout&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kd&quot;&gt;function&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
      &lt;span class=&quot;nb&quot;&gt;navigator&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;splashscreen&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;hide&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;},&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;100&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;fontes: &lt;br /&gt;&lt;a href=&quot;https://cordova.apache.org/docs/en/2.6.0/cordova/splashscreen/splashscreen.hide.html&quot;&gt;Doc Cordova&lt;/a&gt;&lt;br /&gt;
&lt;a href=&quot;https://forum.ionicframework.com/t/white-page-showing-after-splash-screen-before-app-load/2908/9&quot;&gt;Forum Ionic&lt;/a&gt;&lt;/p&gt;</content><author><name>Leonardo Benedeti</name></author><category term="ionic" /><summary type="html">Ao iniciar um projeto ionic, eu reparei que a splash tinha um comportamento estranho. Ao finalizar o fade de saída, a tela do app ainda não tinha carregado, mostrando assim uma tela branca antes do conteúdo. Fui investigar o porque e descobri algumas preferences que corrigem esse comportamento. Normalmente as splash screens servem para preparar o app, e ao finalizar o carregamento dos arquivos ela faz o fade dando foco ao conteúdo da tela inicial do seu aplicativo. Neste post vamos alterar apenas dois arquivos pra que isso de fato aconteça. O config.xml e o app.js Para previnir que a splash execute o fade automaticamente antes do conteúdo estar pronto, você precisa da preference: AutoHideSplashScreen, que é quem previne isso, se estiver com valor false. As demais preferences são para melhorar a experiência da splash, os nomes já se auto explicam né. =D config.xml: &amp;lt;preference name=&quot;AutoHideSplashScreen&quot; value=&quot;false&quot; /&amp;gt; &amp;lt;preference name=&quot;FadeSplashScreenDuration&quot; value=&quot;1000&quot; /&amp;gt; &amp;lt;preference name=&quot;ShowSplashScreenSpinner&quot; value=&quot;false&quot; /&amp;gt; &amp;lt;preference name=&quot;SplashMaintainAspectRatio&quot; value=&quot;true&quot; /&amp;gt; Com os valores do config.xml definidos basta incluir este trecho de código no arquivo app.js para a magia acontecer. Atenção: para ele funcionar como combinado, ele precisa estar dentro do ready, para que assim que de fato ele esteja pronto e a splash pode ser esmaecida. =D app.js: setTimeout(function() { navigator.splashscreen.hide(); }, 100); fontes: Doc Cordova Forum Ionic</summary></entry><entry><title type="html">ng-bind-html on ionic 1</title><link href="http://localhost:4000/bind-of-html-on-ionic-1" rel="alternate" type="text/html" title="ng-bind-html on ionic 1" /><published>2018-01-11T00:00:00-02:00</published><updated>2018-01-11T15:32:16-02:00</updated><id>http://localhost:4000/bind-of-html-on-ionic-1</id><content type="html" xml:base="http://localhost:4000/bind-of-html-on-ionic-1">&lt;p&gt;Trabalhando em um projeto mobile, precisei dinamizar uma página inteira, com isso busquei como fazer tal coisa. Foi ai que encontrei o ng-bind-html.
&lt;br /&gt;Como ele funciona: você basicamente monta todo o html no controller da aplicação e passa para a view como uma variável de escopo, sim, só isso.&lt;/p&gt;

&lt;p&gt;Abaixo criei uma variável dentro do escopo e passei uma string já com o html que queria utilizar.&lt;/p&gt;

&lt;p&gt;Controller:&lt;/p&gt;
&lt;div class=&quot;language-js highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nx&quot;&gt;$scope&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;data_body&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;s1&quot;&gt;'&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;\&lt;/span&gt;&lt;span class=&quot;s1&quot;&gt;
    &amp;lt;h1 class=&quot;text-center&quot;&amp;gt;'&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;+&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;variavel_qualquer_que_queira_utilizar&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;+&lt;/span&gt;&lt;span class=&quot;s1&quot;&gt;'&amp;lt;/h1&amp;gt;&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;\&lt;/span&gt;&lt;span class=&quot;s1&quot;&gt;
'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Já na view, basta passar a variável como valor para a diretiva ng-bind-html e ver a mágica acontecer.&lt;/p&gt;

&lt;p&gt;View:&lt;/p&gt;
&lt;div class=&quot;language-html highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nt&quot;&gt;&amp;lt;div&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;class=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;padding&quot;&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;ng-bind-html=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;data_body&quot;&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&amp;gt;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Infelizmente não tenho as fontes pra isso. Mas não precisa, basta fazer como mostrei acima que vai dar certo. =D&lt;/p&gt;</content><author><name>Leonardo Benedeti</name></author><category term="ionic" /><summary type="html">Trabalhando em um projeto mobile, precisei dinamizar uma página inteira, com isso busquei como fazer tal coisa. Foi ai que encontrei o ng-bind-html. Como ele funciona: você basicamente monta todo o html no controller da aplicação e passa para a view como uma variável de escopo, sim, só isso. Abaixo criei uma variável dentro do escopo e passei uma string já com o html que queria utilizar. Controller: $scope.data_body = '\ &amp;lt;h1 class=&quot;text-center&quot;&amp;gt;'+variavel_qualquer_que_queira_utilizar+'&amp;lt;/h1&amp;gt;\ '; Já na view, basta passar a variável como valor para a diretiva ng-bind-html e ver a mágica acontecer. View: &amp;lt;div class=&quot;padding&quot; ng-bind-html=&quot;data_body&quot;&amp;gt; Infelizmente não tenho as fontes pra isso. Mas não precisa, basta fazer como mostrei acima que vai dar certo. =D</summary></entry><entry><title type="html">Projeto - App Cervejarias</title><link href="http://localhost:4000/projeto-app-cervejarias" rel="alternate" type="text/html" title="Projeto - App Cervejarias" /><published>2017-11-27T00:00:00-02:00</published><updated>2017-11-27T15:32:16-02:00</updated><id>http://localhost:4000/projeto-app-cervejarias</id><content type="html" xml:base="http://localhost:4000/projeto-app-cervejarias">&lt;div class=&quot;grid&quot;&gt;
    &lt;div class=&quot;titulo a text&quot;&gt;
      &lt;h1&gt;App Cervejarias&lt;/h1&gt;
    &lt;/div&gt;
    &lt;div class=&quot;b&quot;&gt;
      &lt;img src=&quot;assets/img/app/img-app-apresentacao.png&quot; alt=&quot;&quot; /&gt;
    &lt;/div&gt;
&lt;/div&gt;
&lt;hr /&gt;
&lt;div class=&quot;grid&quot;&gt;
    &lt;div class=&quot;a img&quot;&gt;
      &lt;img src=&quot;assets/img/app/home.jpg&quot; alt=&quot;&quot; /&gt;
    &lt;/div&gt;
    &lt;div class=&quot;b&quot;&gt;
      &lt;h3&gt;Tela inicial do app&lt;/h3&gt;
      &lt;span&gt;
        Aqui você consegue inserir a logo da cervejaria e alguma ação abaixo da logo, no caso deste projeto a ação foi ler um código de barras para retornar as informações da cerveja. O código está previamente cadastrado em um painel, onde você consegue gerenciar todas as cervejas que vão aparecer no app. 
      &lt;/span&gt;
    &lt;/div&gt;
&lt;/div&gt;
&lt;hr /&gt;
&lt;div class=&quot;grid&quot;&gt;
    &lt;div class=&quot;a img&quot;&gt;
      &lt;img src=&quot;assets/img/app/side-menu.jpg&quot; alt=&quot;&quot; /&gt;
    &lt;/div&gt;
    &lt;div class=&quot;b&quot;&gt;
      &lt;h3&gt;Menu lateral&lt;/h3&gt;
      &lt;span&gt;
        Ele foi desenhado para o usuário conseguir acessar qualquer parte do app em qualquer página principal. Como as páginas que contém as listas de Cervejas, Petiscos, Dicas e além das listas também tem um item que retorna a home. E acima dos itens foi inserida a logo da empresa para melhorar a usabilidade do menu, inserindo um cabeçalho ao menu. 
      &lt;/span&gt;
    &lt;/div&gt;
&lt;/div&gt;
&lt;hr /&gt;
&lt;div class=&quot;grid&quot;&gt;
    &lt;div class=&quot;a img&quot;&gt;
      &lt;img src=&quot;assets/img/app/dicas.jpg&quot; alt=&quot;&quot; /&gt;
    &lt;/div&gt;
    &lt;div class=&quot;b&quot;&gt;
      &lt;h3&gt;Dicas&lt;/h3&gt;
      &lt;span&gt;
        Uma página bem simples no visual e bem complexo por baixo. A tela executa uma busca de cervejas e petiscos que estão cadastrados como dica no banco de dados e os indexa em ordem, separando as cervejas dos petiscos. Cada item da lista leva diretamente ao seu referente detalhamento. 
      &lt;/span&gt;
    &lt;/div&gt;
&lt;/div&gt;
&lt;hr /&gt;
&lt;div class=&quot;grid&quot;&gt;
    &lt;div class=&quot;a img&quot;&gt;
      &lt;img src=&quot;assets/img/app/estilos.jpg&quot; alt=&quot;&quot; /&gt;
    &lt;/div&gt;
    &lt;div class=&quot;b&quot;&gt;
      &lt;h3&gt;Estilos&lt;/h3&gt;
      &lt;span&gt;
        Esta página é bem semelhante a outras do app, é uma simples lista. Porém existe um filtro específico em cada lista. Neste caso o filto são pelos estilos das cervejas disponíveis no banco de dados. Ao buscar as cervejas a página mostra em ordem alfabefica todos os estilos de cervejas disponíveis.
      &lt;/span&gt;
    &lt;/div&gt;
&lt;/div&gt;
&lt;hr /&gt;
&lt;div class=&quot;grid&quot;&gt;
    &lt;div class=&quot;a img&quot;&gt;
      &lt;img src=&quot;assets/img/app/cervejas.jpg&quot; alt=&quot;&quot; /&gt;
    &lt;/div&gt;
    &lt;div class=&quot;b&quot;&gt;
      &lt;h3&gt;Cervejas&lt;/h3&gt;
      &lt;span&gt;
        Página subsequente a pagina de estilos, selecionando seu estilo favorito o app vai fazer uma nova busca trazendo apenas os rótulos de cervejas referentes ao estilo escolhido, possibilitando o usuário a escolher a cerveja desejada.
      &lt;/span&gt;
    &lt;/div&gt;
&lt;/div&gt;
&lt;hr /&gt;
&lt;div class=&quot;grid&quot;&gt;
    &lt;div class=&quot;a img&quot;&gt;
      &lt;img src=&quot;assets/img/app/cerveja.jpg&quot; alt=&quot;&quot; /&gt;
    &lt;/div&gt;
    &lt;div class=&quot;b&quot;&gt;
      &lt;h3&gt;Cerveja&lt;/h3&gt;
      &lt;span&gt;
        Resultado de toda jornada de cliques em busca da cerveja perfeita, esta tela mostra os detalhes da cerveja escolhida, tal como foto, descrição, cervejaria, origem, estilo, graduação alcoolica, copo, temperatura ideal e amargor. O cliente do projeto inicial escolheu não mostrar preço da cerveja, mas isso pode ser configurado facilmente, possibilitando o app funcionar como um catálogo para pedidos, que pode ser usado por vendedores da cervejaria em questão.
      &lt;/span&gt;
    &lt;/div&gt;
&lt;/div&gt;
&lt;hr /&gt;
&lt;div class=&quot;grid&quot;&gt;
    &lt;div class=&quot;a img&quot;&gt;
      &lt;img src=&quot;assets/img/app/petiscos.jpg&quot; alt=&quot;&quot; /&gt;
    &lt;/div&gt;
    &lt;div class=&quot;b&quot;&gt;
      &lt;h3&gt;Petiscos&lt;/h3&gt;
      &lt;span&gt;
        Novamente uma lista simples, tal como a lista de estilos e cervejas, esta lista mostra todos os petiscos disponíveis na casa. Uma lista um pouco mais direta, não tem muitos filtros, tudo que está disponível no banco de dados como petiscos vai aparecer nesta lista para o usuário escolher o que mais lhe agrada.
      &lt;/span&gt;
    &lt;/div&gt;
&lt;/div&gt;
&lt;hr /&gt;
&lt;div class=&quot;grid&quot;&gt;
    &lt;div class=&quot;a img&quot;&gt;
      &lt;img src=&quot;assets/img/app/petisco.jpg&quot; alt=&quot;&quot; /&gt;
    &lt;/div&gt;
    &lt;div class=&quot;b&quot;&gt;
      &lt;h3&gt;Petisco&lt;/h3&gt;
      &lt;span&gt;
        Tela subsequente a lista anterior, mostra também detalhes do petisco, porém com pouco menos detalhes se comparar a tela de cerveja. Está tela mostra apenas o tempo médio de preparo e os ingredientes. 
      &lt;/span&gt;
    &lt;/div&gt;
&lt;/div&gt;
&lt;hr /&gt;
&lt;div class=&quot;grid&quot;&gt;
    &lt;div class=&quot;a img&quot;&gt;
      &lt;img src=&quot;assets/img/app/erro.jpg&quot; alt=&quot;&quot; /&gt;
    &lt;/div&gt;
    &lt;div class=&quot;b&quot;&gt;
      &lt;h3&gt;Erro&lt;/h3&gt;
      &lt;span&gt;
        Todas as requisições ao banco de dados dependem de internet, logo, caso o usuário esteja sem conexão ou até com uma conexão muito lenta, o retorno precisa ser amigável. Com isso todas as requisições acima possuem este erro, no caso a imagem relata o erro de buscar uma cerveja, mas cada tela tem seu erro específico para deixar bem claro ao usuário o que está acontecendo.
      &lt;/span&gt;
    &lt;/div&gt;
&lt;/div&gt;
&lt;hr /&gt;
&lt;div class=&quot;grid&quot;&gt;
    &lt;div class=&quot;a img&quot;&gt;
      &lt;img src=&quot;assets/img/app/foto.jpg&quot; alt=&quot;&quot; /&gt;
    &lt;/div&gt;
    &lt;div class=&quot;b&quot;&gt;
      &lt;h3&gt;Foto e compartilhamento&lt;/h3&gt;
      &lt;span&gt;
        Esta tela agrega muito valor ao negócio do estabelecimento, ao tirar uma foto com o app e confirmar o app inclui na foto a logo do estabelecimento, assim fornecendo uma divulgação da sua marca nas redes sociais do cliente final que está utilizando o app. A foto tirada pode ser compartilhada em qualquer rede social, como Instagram, Facebook, WhatsApp...
      &lt;/span&gt;
    &lt;/div&gt;
&lt;/div&gt;
&lt;hr /&gt;
&lt;div class=&quot;grid&quot;&gt;
    &lt;div class=&quot;a img&quot;&gt;
      &lt;img src=&quot;assets/img/app/barcode.jpg&quot; alt=&quot;&quot; /&gt;
    &lt;/div&gt;
    &lt;div class=&quot;b&quot;&gt;
      &lt;h3&gt;Leitor de código de barras&lt;/h3&gt;
      &lt;span&gt;
        Citado na tela Home, a função de ler os códigos de barras foi o carro chefe do projeto, inicialmente seria apenas para informações básicas da cerveja, mas ai o app se construiu em torno desta funcionalidade, que é bem simples, basta apontar o leitor para o código de barras da sua cerveja e vai encontrar informações da cerveja, caso ela esteja cadastrada no banco de dados. 
      &lt;/span&gt;
    &lt;/div&gt;
&lt;/div&gt;
&lt;hr /&gt;
&lt;div class=&quot;grid&quot;&gt;
    &lt;div class=&quot;a img&quot;&gt;
      &lt;img src=&quot;assets/img/app/tecnologias.jpg&quot; alt=&quot;&quot; /&gt;
    &lt;/div&gt;
    &lt;div class=&quot;b&quot;&gt;
      &lt;h3&gt;Técnologias&lt;/h3&gt;
      &lt;span&gt;
        Para criar o app utilizei o Ionic, framework de desenvolvimento de apps híbridos. E o painel que alimenta o app, foi criado em PHP puro, sem frameworks, que acessa um banco de dados MySQL.
      &lt;/span&gt;
    &lt;/div&gt;
&lt;/div&gt;</content><author><name>Leonardo Benedeti</name></author><category term="web" /><category term="ionic" /><category term="projetos" /><summary type="html">App Cervejarias Tela inicial do app Aqui você consegue inserir a logo da cervejaria e alguma ação abaixo da logo, no caso deste projeto a ação foi ler um código de barras para retornar as informações da cerveja. O código está previamente cadastrado em um painel, onde você consegue gerenciar todas as cervejas que vão aparecer no app. Menu lateral Ele foi desenhado para o usuário conseguir acessar qualquer parte do app em qualquer página principal. Como as páginas que contém as listas de Cervejas, Petiscos, Dicas e além das listas também tem um item que retorna a home. E acima dos itens foi inserida a logo da empresa para melhorar a usabilidade do menu, inserindo um cabeçalho ao menu. Dicas Uma página bem simples no visual e bem complexo por baixo. A tela executa uma busca de cervejas e petiscos que estão cadastrados como dica no banco de dados e os indexa em ordem, separando as cervejas dos petiscos. Cada item da lista leva diretamente ao seu referente detalhamento. Estilos Esta página é bem semelhante a outras do app, é uma simples lista. Porém existe um filtro específico em cada lista. Neste caso o filto são pelos estilos das cervejas disponíveis no banco de dados. Ao buscar as cervejas a página mostra em ordem alfabefica todos os estilos de cervejas disponíveis. Cervejas Página subsequente a pagina de estilos, selecionando seu estilo favorito o app vai fazer uma nova busca trazendo apenas os rótulos de cervejas referentes ao estilo escolhido, possibilitando o usuário a escolher a cerveja desejada. Cerveja Resultado de toda jornada de cliques em busca da cerveja perfeita, esta tela mostra os detalhes da cerveja escolhida, tal como foto, descrição, cervejaria, origem, estilo, graduação alcoolica, copo, temperatura ideal e amargor. O cliente do projeto inicial escolheu não mostrar preço da cerveja, mas isso pode ser configurado facilmente, possibilitando o app funcionar como um catálogo para pedidos, que pode ser usado por vendedores da cervejaria em questão. Petiscos Novamente uma lista simples, tal como a lista de estilos e cervejas, esta lista mostra todos os petiscos disponíveis na casa. Uma lista um pouco mais direta, não tem muitos filtros, tudo que está disponível no banco de dados como petiscos vai aparecer nesta lista para o usuário escolher o que mais lhe agrada. Petisco Tela subsequente a lista anterior, mostra também detalhes do petisco, porém com pouco menos detalhes se comparar a tela de cerveja. Está tela mostra apenas o tempo médio de preparo e os ingredientes. Erro Todas as requisições ao banco de dados dependem de internet, logo, caso o usuário esteja sem conexão ou até com uma conexão muito lenta, o retorno precisa ser amigável. Com isso todas as requisições acima possuem este erro, no caso a imagem relata o erro de buscar uma cerveja, mas cada tela tem seu erro específico para deixar bem claro ao usuário o que está acontecendo. Foto e compartilhamento Esta tela agrega muito valor ao negócio do estabelecimento, ao tirar uma foto com o app e confirmar o app inclui na foto a logo do estabelecimento, assim fornecendo uma divulgação da sua marca nas redes sociais do cliente final que está utilizando o app. A foto tirada pode ser compartilhada em qualquer rede social, como Instagram, Facebook, WhatsApp... Leitor de código de barras Citado na tela Home, a função de ler os códigos de barras foi o carro chefe do projeto, inicialmente seria apenas para informações básicas da cerveja, mas ai o app se construiu em torno desta funcionalidade, que é bem simples, basta apontar o leitor para o código de barras da sua cerveja e vai encontrar informações da cerveja, caso ela esteja cadastrada no banco de dados. Técnologias Para criar o app utilizei o Ionic, framework de desenvolvimento de apps híbridos. E o painel que alimenta o app, foi criado em PHP puro, sem frameworks, que acessa um banco de dados MySQL.</summary></entry><entry><title type="html">SimpleForm - Incluindo formulários simples em sites estáticos</title><link href="http://localhost:4000/inclusao-de-form-a-sites-estaticos" rel="alternate" type="text/html" title="SimpleForm - Incluindo formulários simples em sites estáticos" /><published>2017-11-22T00:00:00-02:00</published><updated>2017-11-22T15:32:16-02:00</updated><id>http://localhost:4000/inclusao-de-form-a-sites-estaticos</id><content type="html" xml:base="http://localhost:4000/inclusao-de-form-a-sites-estaticos">&lt;p&gt;Em uma alteração neste site, precisei criar um formulário de envio de emails, porém, como fazer isso com meu site hospedado no GitHubPages e ele sendo um site estático, todo em HTML ?&lt;/p&gt;

&lt;p&gt;Após uma busca, econtrei uma ferramenta muito interessante que envia emails através de uma api. Você passa o seu token e já era. O email é enviado pra você como um formulário padrão de um site hospedado em um servidor completo.&lt;/p&gt;

&lt;p&gt;A ferramenta se chama &lt;a href=&quot;https://getsimpleform.com/&quot;&gt;Simple Form&lt;/a&gt; e é gratuita. Basta entrar no site e pedir um token que é enviado pro seu email e já pode ser usado.
É de fato muito simples.&lt;/p&gt;

&lt;p&gt;#ficadica&lt;/p&gt;</content><author><name>Leonardo Benedeti</name></author><category term="web" /><category term="jekyll" /><summary type="html">Em uma alteração neste site, precisei criar um formulário de envio de emails, porém, como fazer isso com meu site hospedado no GitHubPages e ele sendo um site estático, todo em HTML ? Após uma busca, econtrei uma ferramenta muito interessante que envia emails através de uma api. Você passa o seu token e já era. O email é enviado pra você como um formulário padrão de um site hospedado em um servidor completo. A ferramenta se chama Simple Form e é gratuita. Basta entrar no site e pedir um token que é enviado pro seu email e já pode ser usado. É de fato muito simples. #ficadica</summary></entry><entry><title type="html">Jekyll - Criação de blog e sites</title><link href="http://localhost:4000/criacao-de-sites-ou-blogs-com-jekyll" rel="alternate" type="text/html" title="Jekyll - Criação de blog e sites" /><published>2017-11-21T00:00:00-02:00</published><updated>2017-11-21T15:32:16-02:00</updated><id>http://localhost:4000/criacao-de-sites-ou-blogs-com-jekyll</id><content type="html" xml:base="http://localhost:4000/criacao-de-sites-ou-blogs-com-jekyll">&lt;p&gt;Todo desenvolvedor tem a necessidade pessoal de montar seu próprio site ou blog para mostrar seus trabalhos de uma maneira mais amigável, né?!
Comigo não foi diferente, porém no meu caso, precisava de algo mais simples e que não me demandasse tanto tempo para criar um site, precisava que fosse rápido, simples e funcional. Com isso iniciei as buscas e encontrei uma magia chamada Jekyll, basicamente um criador de páginas estáticas a partir de arquivos Markdown.&lt;/p&gt;

&lt;p&gt;Este site que você navega, foi criado com esta ferramenta. O intuito era ter uma base de conhecimento muito simples com um acesso mais fácil e melhor indexada, porém com a facilidade de montar e alterar templates e conteúdo, também incrementei com minhas informações profissionais, assim tentando substituir o tão formal currículo de papel. Que ainda tenho se precisar rsrs.&lt;/p&gt;

&lt;p&gt;Pra utilizar o a criação de um site básico e já totalmente indexado basta rodar os comandos abaixo:&lt;/p&gt;
&lt;div class=&quot;language-terminal highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;gp&quot;&gt;#&lt;/span&gt; Install Jekyll and Bundler gems through RubyGems
&lt;span class=&quot;go&quot;&gt;gem install jekyll bundler

&lt;/span&gt;&lt;span class=&quot;gp&quot;&gt;#&lt;/span&gt; Create a new Jekyll site at ./myblog
&lt;span class=&quot;go&quot;&gt;jekyll new myblog

&lt;/span&gt;&lt;span class=&quot;gp&quot;&gt;#&lt;/span&gt; Change into your new directory
&lt;span class=&quot;go&quot;&gt;cd myblog

&lt;/span&gt;&lt;span class=&quot;gp&quot;&gt;#&lt;/span&gt; Build the site on the preview server
&lt;span class=&quot;go&quot;&gt;bundle exec jekyll serve
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Com esses comandos &lt;del&gt;e muitos outros pra configurar o ambiente que não vem ao caso por cada máquina ter suas particularidades&lt;/del&gt; você consegue criar um blog ou site estático de maneira muito simples. A maior vantagem pra mim é que já tinha costume em escrever os &lt;code class=&quot;highlighter-rouge&quot;&gt;*.md&lt;/code&gt; para repositórios onde contribuo, assim atingindo a meta de conseguir criar uma página do jeito que precisava em pouco tempo.&lt;/p&gt;

&lt;p&gt;Enfim…&lt;/p&gt;

&lt;p&gt;Pra conhecer mais detalhes da plataforma, segue abaixo links para documentação oficial e um curso gratuito no Udemy, curso este que assisti enquanto criava este site.&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://jekyllrb.com/&quot;&gt;Documentação oficial&lt;/a&gt;&lt;br /&gt;
&lt;a href=&quot;https://www.udemy.com/criando-sites-estaticos-com-jekyll/&quot;&gt;Curso no Udemy&lt;/a&gt;&lt;/p&gt;</content><author><name>Leonardo Benedeti</name></author><category term="web" /><category term="jekyll" /><summary type="html">Todo desenvolvedor tem a necessidade pessoal de montar seu próprio site ou blog para mostrar seus trabalhos de uma maneira mais amigável, né?! Comigo não foi diferente, porém no meu caso, precisava de algo mais simples e que não me demandasse tanto tempo para criar um site, precisava que fosse rápido, simples e funcional. Com isso iniciei as buscas e encontrei uma magia chamada Jekyll, basicamente um criador de páginas estáticas a partir de arquivos Markdown. Este site que você navega, foi criado com esta ferramenta. O intuito era ter uma base de conhecimento muito simples com um acesso mais fácil e melhor indexada, porém com a facilidade de montar e alterar templates e conteúdo, também incrementei com minhas informações profissionais, assim tentando substituir o tão formal currículo de papel. Que ainda tenho se precisar rsrs. Pra utilizar o a criação de um site básico e já totalmente indexado basta rodar os comandos abaixo: # Install Jekyll and Bundler gems through RubyGems gem install jekyll bundler # Create a new Jekyll site at ./myblog jekyll new myblog # Change into your new directory cd myblog # Build the site on the preview server bundle exec jekyll serve Com esses comandos e muitos outros pra configurar o ambiente que não vem ao caso por cada máquina ter suas particularidades você consegue criar um blog ou site estático de maneira muito simples. A maior vantagem pra mim é que já tinha costume em escrever os *.md para repositórios onde contribuo, assim atingindo a meta de conseguir criar uma página do jeito que precisava em pouco tempo. Enfim… Pra conhecer mais detalhes da plataforma, segue abaixo links para documentação oficial e um curso gratuito no Udemy, curso este que assisti enquanto criava este site. Documentação oficial Curso no Udemy</summary></entry><entry><title type="html">Status bar ionic1 rodando no iOS 11</title><link href="http://localhost:4000/status-bar-ios11-ionic1" rel="alternate" type="text/html" title="Status bar ionic1 rodando no iOS 11" /><published>2017-11-03T00:00:00-02:00</published><updated>2017-11-03T15:32:16-02:00</updated><id>http://localhost:4000/status-bar-ios11-ionic1</id><content type="html" xml:base="http://localhost:4000/status-bar-ios11-ionic1">&lt;p&gt;Em uma alteração de um aplicativo que eu mantenho, me deparei com o problema relacionado a status bar do iOS 11.
O app ficou com o header maior por não utilizar setar a cor de background da status bar, com isso ocorreram quebras de layout e a própria status bar ficou sem cor.&lt;/p&gt;

&lt;p&gt;Depois de uma boa busca pelo assunto, encontrei o plugin que resolvia isso e logo adicionei ao projeto&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;ionic plugin add cordova-plugin-disable-ios11-statusbar
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Após a inclusão do plugin, bastou gerar um novo build e tudo se resolveu. Apenas para o iOS 11, para o iPhone X ainda não consegui testar, mas a solução deve ser bem próxima.&lt;/p&gt;

&lt;p&gt;fonte: &lt;a href=&quot;https://issues.apache.org/jira/browse/CB-12886&quot;&gt;Issues Apache&lt;/a&gt;&lt;/p&gt;</content><author><name>Leonardo Benedeti</name></author><category term="ionic" /><category term="ios" /><summary type="html">Em uma alteração de um aplicativo que eu mantenho, me deparei com o problema relacionado a status bar do iOS 11. O app ficou com o header maior por não utilizar setar a cor de background da status bar, com isso ocorreram quebras de layout e a própria status bar ficou sem cor. Depois de uma boa busca pelo assunto, encontrei o plugin que resolvia isso e logo adicionei ao projeto ionic plugin add cordova-plugin-disable-ios11-statusbar Após a inclusão do plugin, bastou gerar um novo build e tudo se resolveu. Apenas para o iOS 11, para o iPhone X ainda não consegui testar, mas a solução deve ser bem próxima. fonte: Issues Apache</summary></entry></feed>